fn main() {
    println!("product: {}",slope_product!(INPUT,0,1,2,3,4));
}


#[macro_export]
macro_rules! slope_product {
    ( $input:expr,$( $x:expr ),* ) => {
        {
            let mut prod = 1;
            $(
                println!("slope: {}",slope!($x,$input));
                prod*=slope!($x,$input);
            )*
            prod
        }
    };
}

#[macro_export]
macro_rules! slope {
    (  $slope:expr,$input:expr ) => {
        {
            $input.lines()
                    .enumerate()
                    .filter(|x| {is_tree!($slope,x.0,x.1)})
                    .count()
        }
    };
}

#[macro_export]
macro_rules! is_tree {
    (4,$i:expr,$s:expr) => {
        {
            match $i % 2 {
                0 => is_tree!(0,$i,$s),
                _ => false
            }
        }
    };
    ($slope:expr,$i:expr,$s:expr) => {
        {
            $s.chars().nth(($i*(1+$slope*2))%$s.chars().count()).unwrap() == '#'
        }
    };

}

const INPUT: &str ="..##.........##.........##.........##.........##.........##.......
#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
.#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
.#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
..#.##.......#.##.......#.##.......#.##.......#.##.......#.##.....
.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
.#........#.#........#.#........#.#........#.#........#.#........#
#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...
#...##....##...##....##...##....##...##....##...##....##...##....#
.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#
";