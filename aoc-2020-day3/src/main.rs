fn main() {

    println!("{}",INPUT.lines()
                .enumerate()
                .filter(|x| { (x.0%2 == 0) && (x.1.chars().nth((x.0/2)%31).unwrap() == '#')})
                .count());
}


#[macro_export]
macro_rules! slope_product {
    ( $input:expr,$( $x:expr ),* ) => {
        {
            let mut prod = 1;
            $(
                println!("slope: {}",slope!($x,$input));
                prod*=slope!($x,$input);
            )*
            prod
        }
    };
}

#[macro_export]
macro_rules! slope {
    (  $slope:expr,$input:expr ) => {
        {
            $input.lines()
                    .enumerate()
                    .filter(|x| {is_tree!($slope,x.0,x.1)})
                    .count()
        }
    };
}

#[macro_export]
macro_rules! is_tree {
    ($slope:expr,$i:expr,$s:expr) => {
        {
            match $slope {
                4 => {(($i%2)==0) && $s.chars().nth(($i/2)%$s.chars().count()).unwrap() == '#'},
                _ => $s.chars().nth(($i*(1+$slope*2))%$s.chars().count()).unwrap() == '#'
            }

        }
    };

}

const INPUT: &str ="..##.........##.........##.........##.........##.........##.......
	#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..#...#...#..
	.#....#..#..#....#..#..#....#..#..#....#..#..#....#..#..#....#..#.
	..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#..#.#...#.#
	.#...##..#..#...##..#..#...##..#..#...##..#..#...##..#..#...##..#.
	..#.##.......#.##.......#.##.......#.##.......#.##.......#.##.....
	.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#.#.#.#....#
	.#........#.#........#.#........#.#........#.#........#.#........#
	#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...#.##...#...
	#...##....##...##....##...##....##...##....##...##....##...##....#
	.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#.#..#...#.#
	";